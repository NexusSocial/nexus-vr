mod chad;
mod trad;

use clap::Parser;
use color_eyre::Result;
use futures_lite::FutureExt;
use tracing_subscriber::{filter::LevelFilter, EnvFilter};

/// My Program that does awesome things
#[derive(Parser, Debug, Clone)]
#[clap(author, version, about)]
pub struct Args {
	/// Sets a custom port number
	#[clap(short, long)]
	port: Option<u16>,

	/// Sets a list of domain names for the certificate. The first one will be
	/// used as the domain name shown to users in URLs generated by the server.
	#[clap(short, long, required = true)]
	subject_alt_names: Vec<String>,
}

pub async fn main(args: Args) -> Result<()> {
	color_eyre::install()?;
	let env_filter = EnvFilter::builder()
		.with_default_directive(LevelFilter::INFO.into())
		.from_env_lossy();

	tracing_subscriber::fmt()
		.with_target(true)
		.with_level(true)
		.with_env_filter(env_filter)
		.init();

	let chad_fut = self::chad::launch_webtransport_server(args.clone());
	let trad_fut = self::trad::launch_http_server(args.clone());

	chad_fut.race(trad_fut).await?;

	Ok(())
}
